---
title: Document API
sidebarTitle: Document API
description: A stable, engine-agnostic interface for programmatic document access
keywords: "document api, programmatic access, query documents, document manipulation, headless docx"
---

Document API gives you a consistent way to read and edit documents without relying on editor internals.

<Info>
Document API is in <strong>alpha</strong> and subject to breaking changes while the contract and adapters continue to evolve. The current API is not yet comprehensive, and more commands and namespaces are being added on an ongoing basis.
</Info>

## Why use Document API

- Build automations without editor-specific code.
- Work with predictable inputs and outputs defined per operation.
- Check capabilities up front and branch safely when features are unavailable.

## Reference

- Full operation reference: [/document-api/reference/index](/document-api/reference/index)
- Machine-readable files are available for automation use (contract schema, tool manifest, and agent compatibility artifacts).

## Common workflows

These are the recommended patterns for new integrations.

### Plan with query.match, then apply with mutations

This is the recommended default for most apps: match first, preview, then apply.

```ts
const match = editor.doc.query.match({
  select: { type: 'text', pattern: 'foo' },
  require: 'first',
});

const ref = match.items?.[0]?.handle?.ref;
if (!ref) return;

const plan = {
  expectedRevision: match.evaluatedRevision,
  atomic: true,
  changeMode: 'direct',
  steps: [
    {
      id: 'replace-foo',
      op: 'text.rewrite',
      where: { by: 'ref', ref },
      args: { replacement: { text: 'bar' } },
    },
  ],
};

const preview = editor.doc.mutations.preview(plan);
if (preview.valid) {
  editor.doc.mutations.apply(plan);
}
```

### Run multiple edits as one plan

When several changes should stay together, group them into one plan:

```ts
const match = editor.doc.query.match({
  select: { type: 'text', pattern: 'payment terms' },
  require: 'first',
});

const ref = match.items?.[0]?.handle?.ref;
if (!ref) return;

const plan = {
  expectedRevision: match.evaluatedRevision,
  atomic: true,
  changeMode: 'direct',
  steps: [
    {
      id: 'rewrite-terms',
      op: 'text.rewrite',
      where: { by: 'ref', ref },
      args: {
        replacement: { text: 'updated payment terms' },
      },
    },
    {
      id: 'format-terms',
      op: 'format.apply',
      where: { by: 'ref', ref },
      args: {
        marks: { bold: true },
      },
    },
  ],
};

const preview = editor.doc.mutations.preview(plan);
if (preview.valid) {
  editor.doc.mutations.apply(plan);
}
```

### Quick search and single edit

For lightweight tasks, `find` is still a good option:

```ts
const result = editor.doc.find({
  select: { type: 'text', pattern: 'foo' },
  require: 'first',
});

const target = result.items?.[0]?.context?.textRanges?.[0];
if (target) {
  editor.doc.replace({ target, text: 'bar' });
}
```

### Tracked-mode insert

Insert text as a tracked change so reviewers can accept or reject it:

```ts
const receipt = editor.doc.insert(
  { text: 'new content' },
  { changeMode: 'tracked' },
);
```

The receipt includes a `resolution` with the resolved insertion point and `inserted` entries with tracked-change IDs.

### Check capabilities before acting

Use `capabilities()` to branch on what the editor supports:

```ts
const caps = editor.doc.capabilities();
const target = { kind: 'text', blockId: 'p1', range: { start: 0, end: 3 } };

if (caps.operations['format.apply'].available) {
  editor.doc.format.apply({
    target,
    marks: { bold: true },
  });
}

if (caps.global.trackChanges.enabled) {
  editor.doc.insert({ text: 'tracked' }, { changeMode: 'tracked' });
}
```

### Dry-run preview

Pass `dryRun: true` to validate an operation without applying it:

```ts
const preview = editor.doc.insert(
  { target, text: 'hello' },
  { dryRun: true },
);
// preview.success tells you whether the insert would succeed
// preview.resolution shows the resolved target range
```

{/* DOC_API_OPERATIONS_START */}
### Available operations

Use the tables below to see what operations are available and where each one is documented.

| Namespace | Operations | Reference |
| --- | --- | --- |
| Capabilities | 1 | [Reference](/document-api/reference/capabilities/index) |
| Comments | 5 | [Reference](/document-api/reference/comments/index) |
| Core | 8 | [Reference](/document-api/reference/core/index) |
| Create | 2 | [Reference](/document-api/reference/create/index) |
| Format | 1 | [Reference](/document-api/reference/format/index) |
| Lists | 8 | [Reference](/document-api/reference/lists/index) |
| Mutations | 2 | [Reference](/document-api/reference/mutations/index) |
| Query | 1 | [Reference](/document-api/reference/query/index) |
| Review | 1 | [Reference](/document-api/reference/review/index) |
| Track Changes | 2 | [Reference](/document-api/reference/track-changes/index) |

| Editor method | Operation ID |
| --- | --- |
| `editor.doc.find(...)` | [`find`](/document-api/reference/find) |
| `editor.doc.getNode(...)` | [`getNode`](/document-api/reference/get-node) |
| `editor.doc.getNodeById(...)` | [`getNodeById`](/document-api/reference/get-node-by-id) |
| `editor.doc.getText(...)` | [`getText`](/document-api/reference/get-text) |
| `editor.doc.info(...)` | [`info`](/document-api/reference/info) |
| `editor.doc.insert(...)` | [`insert`](/document-api/reference/insert) |
| `editor.doc.replace(...)` | [`replace`](/document-api/reference/replace) |
| `editor.doc.delete(...)` | [`delete`](/document-api/reference/delete) |
| `editor.doc.format.apply(...)` | [`format.apply`](/document-api/reference/format/apply) |
| `editor.doc.create.paragraph(...)` | [`create.paragraph`](/document-api/reference/create/paragraph) |
| `editor.doc.create.heading(...)` | [`create.heading`](/document-api/reference/create/heading) |
| `editor.doc.lists.list(...)` | [`lists.list`](/document-api/reference/lists/list) |
| `editor.doc.lists.get(...)` | [`lists.get`](/document-api/reference/lists/get) |
| `editor.doc.lists.insert(...)` | [`lists.insert`](/document-api/reference/lists/insert) |
| `editor.doc.lists.setType(...)` | [`lists.setType`](/document-api/reference/lists/set-type) |
| `editor.doc.lists.indent(...)` | [`lists.indent`](/document-api/reference/lists/indent) |
| `editor.doc.lists.outdent(...)` | [`lists.outdent`](/document-api/reference/lists/outdent) |
| `editor.doc.lists.restart(...)` | [`lists.restart`](/document-api/reference/lists/restart) |
| `editor.doc.lists.exit(...)` | [`lists.exit`](/document-api/reference/lists/exit) |
| `editor.doc.comments.create(...)` | [`comments.create`](/document-api/reference/comments/create) |
| `editor.doc.comments.patch(...)` | [`comments.patch`](/document-api/reference/comments/patch) |
| `editor.doc.comments.delete(...)` | [`comments.delete`](/document-api/reference/comments/delete) |
| `editor.doc.comments.get(...)` | [`comments.get`](/document-api/reference/comments/get) |
| `editor.doc.comments.list(...)` | [`comments.list`](/document-api/reference/comments/list) |
| `editor.doc.trackChanges.list(...)` | [`trackChanges.list`](/document-api/reference/track-changes/list) |
| `editor.doc.trackChanges.get(...)` | [`trackChanges.get`](/document-api/reference/track-changes/get) |
| `editor.doc.review.decide(...)` | [`review.decide`](/document-api/reference/review/decide) |
| `editor.doc.query.match(...)` | [`query.match`](/document-api/reference/query/match) |
| `editor.doc.mutations.preview(...)` | [`mutations.preview`](/document-api/reference/mutations/preview) |
| `editor.doc.mutations.apply(...)` | [`mutations.apply`](/document-api/reference/mutations/apply) |
| `editor.doc.capabilities()` | [`capabilities.get`](/document-api/reference/capabilities/get) |
{/* DOC_API_OPERATIONS_END */}
