/**
 * EMF/WMF to SVG Converter
 *
 * Converts Windows Enhanced Metafile (EMF) and Windows Metafile (WMF) images
 * to SVG format. The converted SVG is returned as a data URI that can be used
 * as an image source.
 *
 * EMF/WMF rendering code extracted from rtf.js (MIT License)
 * Original: https://github.com/nicktf/rtf.js
 * Copyright (c) 2016 Tom Zoehner, Copyright (c) 2018 Thomas Bluemel
 *
 * @module metafile-converter
 */

/* global btoa, XMLSerializer */

import { EMFJS, WMFJS } from './rtfjs';
import { base64ToUint8Array } from '../../../../helpers.js';

// Disable verbose logging from the renderers
EMFJS.loggingEnabled(false);
WMFJS.loggingEnabled(false);

// Optional DOM environment provided by callers (e.g., JSDOM in Node)
let domEnvironment = null;

/**
 * Configure a DOM environment that can be used when running in Node.
 *
 * @param {{ mockWindow?: Window|null, window?: Window|null, mockDocument?: Document|null, document?: Document|null }|null} env
 */
export const setMetafileDomEnvironment = (env) => {
  domEnvironment = env || null;
};

/**
 * Ensure required DOM globals exist. Returns true if a usable DOM is present.
 */
function ensureDomEnvironment() {
  // Already present
  const hasDom = typeof document !== 'undefined' && typeof XMLSerializer !== 'undefined';
  if (hasDom) return true;

  const env = domEnvironment || {};
  const win = env.window || env.mockWindow || null;
  const doc = env.document || env.mockDocument || win?.document || null;

  if (win && doc) {
    if (typeof globalThis.window === 'undefined') globalThis.window = win;
    if (typeof globalThis.document === 'undefined') globalThis.document = doc;
    if (win.XMLSerializer && typeof globalThis.XMLSerializer === 'undefined') {
      globalThis.XMLSerializer = win.XMLSerializer;
    }
    if (win.Node && typeof globalThis.Node === 'undefined') {
      globalThis.Node = win.Node;
    }
    if (typeof globalThis.atob === 'undefined' && typeof win.atob === 'function') {
      globalThis.atob = win.atob.bind(win);
    }
    if (typeof globalThis.btoa === 'undefined' && typeof win.btoa === 'function') {
      globalThis.btoa = win.btoa.bind(win);
    }
  }

  return typeof document !== 'undefined' && typeof XMLSerializer !== 'undefined';
}

/**
 * Default map mode for metafile rendering.
 * MM_ANISOTROPIC (8) allows independent scaling of x and y axes.
 */
const MM_ANISOTROPIC = 8;

const EMF_SIGNATURE = 0x464d4520; // ' EMF'
const EMF_PLUS_SIGNATURE = 0x2b464d45; // 'EMF+' inside EMR_COMMENT

/**
 * Converts input data to an ArrayBuffer.
 *
 * Accepts:
 * - ArrayBuffer
 * - TypedArray / Buffer
 * - base64 string or data URI
 *
 * @param {string|ArrayBuffer|Uint8Array} data
 * @returns {ArrayBuffer}
 */
function base64ToArrayBuffer(data) {
  if (data instanceof ArrayBuffer) return data;
  if (ArrayBuffer.isView(data)) return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);

  if (typeof data !== 'string') {
    throw new Error('Unsupported data type for conversion to ArrayBuffer');
  }

  // Handle both data URI format and raw base64
  let base64 = data;

  // Check if it's a data URI and extract the base64 portion
  if (data.startsWith('data:')) {
    const commaIndex = data.indexOf(',');
    if (commaIndex === -1) {
      throw new Error('Invalid data URI: missing base64 content');
    }
    base64 = data.substring(commaIndex + 1);
  }

  return base64ToUint8Array(base64).buffer;
}

/**
 * Encodes a Uint8Array into base64 using chunked processing to avoid call stack overflows.
 *
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function uint8ToBase64(bytes) {
  const chunkSize = 0x8000; // 32KB chunks to avoid exceeding the argument limit
  let binary = '';

  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode.apply(null, chunk);
  }

  return btoa(binary);
}

/**
 * Some EMF files generated by Office contain a single STRETCHDIBITS record with an embedded bitmap.
 * rtf.js does not render this record, which results in an empty SVG. This helper extracts the bitmap
 * payload and wraps it in a BMP data URI so the image can still be rendered in the editor.
 *
 * @param {ArrayBuffer} buffer
 * @returns {{ dataUri: string, format: string } | null}
 */
function extractBitmapFromEmf(buffer) {
  const view = new DataView(buffer);
  if (view.byteLength < 120) return null;

  const type = view.getUint32(0, true);
  const headerSize = view.getUint32(4, true);
  if (type !== 0x00000001 || headerSize <= 0 || headerSize + 80 > view.byteLength) return null;

  const recordOffset = headerSize;
  const recordType = view.getUint32(recordOffset, true);
  // EMR_STRETCHDIBITS = 0x51 (81)
  if (recordType !== 0x00000051) return null;

  const recordSize = view.getUint32(recordOffset + 4, true);
  if (recordOffset + recordSize > view.byteLength) return null;

  const offBmi = view.getUint32(recordOffset + 48, true);
  const cbBmi = view.getUint32(recordOffset + 52, true);
  const offBits = view.getUint32(recordOffset + 56, true);
  const cbBits = view.getUint32(recordOffset + 60, true);

  if (!cbBmi || !cbBits) return null;
  const bmiStart = recordOffset + offBmi;
  const bitsStart = recordOffset + offBits;
  if (bitsStart + cbBits > view.byteLength || bmiStart + cbBmi > view.byteLength) return null;

  // Construct a BMP: 14-byte file header + DIB header + bitmap data.
  const bmpSize = 14 + cbBmi + cbBits;
  const bmpBytes = new Uint8Array(bmpSize);
  const bmpView = new DataView(bmpBytes.buffer);
  // Signature 'BM'
  bmpView.setUint8(0, 0x42);
  bmpView.setUint8(1, 0x4d);
  bmpView.setUint32(2, bmpSize, true); // file size
  bmpView.setUint32(10, 14 + cbBmi, true); // pixel data offset

  bmpBytes.set(new Uint8Array(buffer, bmiStart, cbBmi), 14);
  bmpBytes.set(new Uint8Array(buffer, bitsStart, cbBits), 14 + cbBmi);

  return { dataUri: `data:image/bmp;base64,${uint8ToBase64(bmpBytes)}`, format: 'bmp' };
}

/**
 * Converts an SVG element to a base64 data URI string.
 *
 * @param {SVGElement} svgElement - The SVG element to convert
 * @returns {string} Base64 data URI containing the SVG
 */
function svgToDataUri(svgElement) {
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svgElement);
  // Use base64 encoding to be compatible with image processing code that expects base64 data URIs
  const base64 = btoa(unescape(encodeURIComponent(svgString)));
  return `data:image/svg+xml;base64,${base64}`;
}

/**
 * Extracts dimensions from EMF file header.
 *
 * EMF files contain frame bounds in the header that define the image dimensions.
 * The frame is specified in 0.01mm units and needs to be converted to pixels.
 *
 * @param {ArrayBuffer} buffer - The EMF file data
 * @returns {{ width: number, height: number, xExt: number, yExt: number }} Dimensions and extents
 */
function getEmfDimensions(buffer) {
  const view = new DataView(buffer);

  // EMF header structure:
  // Offset 0: type (4 bytes) - should be 1
  // Offset 4: size (4 bytes) - header size
  // Offset 8: bounds (16 bytes) - bounding rectangle in device units
  // Offset 24: frame (16 bytes) - frame rectangle in 0.01mm units

  // Read frame rectangle (in 0.01mm units)
  const frameLeft = view.getInt32(24, true);
  const frameTop = view.getInt32(28, true);
  const frameRight = view.getInt32(32, true);
  const frameBottom = view.getInt32(36, true);

  // Calculate dimensions in 0.01mm units
  const frameWidth = frameRight - frameLeft;
  const frameHeight = frameBottom - frameTop;

  // Convert to pixels (assuming 96 DPI)
  // 1 inch = 25.4mm = 2540 * 0.01mm
  // pixels = (0.01mm units) * 96 / 2540
  const DPI = 96;
  const width = Math.round((frameWidth * DPI) / 2540);
  const height = Math.round((frameHeight * DPI) / 2540);

  // Read device size from header for viewport extents
  // Offset 72: szlDevice (8 bytes) - device size in pixels
  const deviceWidth = view.getInt32(72, true);
  const deviceHeight = view.getInt32(76, true);

  // Use frame dimensions for viewBox extents
  return {
    width: width || 800,
    height: height || 600,
    xExt: frameWidth || deviceWidth || 800,
    yExt: frameHeight || deviceHeight || 600,
    wExt: frameWidth || deviceWidth || 800,
    hExt: frameHeight || deviceHeight || 600,
  };
}

/**
 * Detect if an EMF file contains EMF+ payloads.
 * EMF+ lives inside EMR_COMMENT records with identifier 0x2B464D45.
 *
 * @param {ArrayBuffer} buffer
 * @returns {boolean}
 */
function isEmfPlus(buffer) {
  const view = new DataView(buffer);
  if (view.byteLength < 108) return false;

  const type = view.getUint32(0, true);
  const headerSize = view.getUint32(4, true);
  const signature = view.getUint32(40, true);

  if (type !== 1 || signature !== EMF_SIGNATURE || headerSize <= 0 || headerSize >= view.byteLength) return false;

  let offset = headerSize;
  // Scan only a handful of records to avoid heavy work; EMF+ appears early.
  for (let i = 0; i < 10; i++) {
    if (offset + 8 > view.byteLength) break;
    const recordType = view.getUint32(offset, true);
    const recordSize = view.getUint32(offset + 4, true);
    if (recordSize < 8 || offset + recordSize > view.byteLength) break;

    if (recordType === 70 /* EMR_COMMENT */ && recordSize >= 20) {
      // EMR_COMMENT layout: Type (4) | Size (4) | DataSize (4) | CommentIdentifier (4) | Data...
      const identifier = view.getUint32(offset + 12, true);
      if (identifier === EMF_PLUS_SIGNATURE) return true;
    }

    offset += recordSize;
  }

  return false;
}

/**
 * Detect if a buffer starts with an EMF header (even if the extension is .wmf).
 * @param {ArrayBuffer} buffer
 * @returns {boolean}
 */
function isEmfHeader(buffer) {
  if (buffer.byteLength < 48) return false;
  const view = new DataView(buffer);
  const type = view.getUint32(0, true);
  const signature = view.getUint32(40, true);
  return type === 1 && signature === EMF_SIGNATURE;
}

/**
 * Create a simple placeholder SVG at the requested size.
 * @param {{ width?: number, height?: number, label: string }} params
 * @returns {{ dataUri: string, format: string }}
 */
function createPlaceholder(params) {
  const width = Math.max(1, Math.round(params.width || 400));
  const height = Math.max(1, Math.round(params.height || 300));
  const label = params.label || 'Unable to render image';

  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" role="img" aria-label="${label}"><rect width="100%" height="100%" fill="#ffffff" stroke="#d9d9d9" stroke-width="1"/><text x="50%" y="50%" fill="#595959" font-family="sans-serif" font-size="${Math.max(
    8,
    Math.min(12, Math.floor(width / 30)),
  )}" text-anchor="middle" dominant-baseline="middle">${label}</text></svg>`;
  const base64 = btoa(unescape(encodeURIComponent(svg)));
  return { dataUri: `data:image/svg+xml;base64,${base64}`, format: 'svg' };
}

/**
 * Extracts dimensions from WMF file header.
 *
 * @param {ArrayBuffer} buffer - The WMF file data
 * @returns {{ width: number, height: number, xExt: number, yExt: number }} Dimensions and extents
 */
function getWmfDimensions(buffer) {
  const view = new DataView(buffer);

  // Check for placeable WMF header (starts with magic number 0x9AC6CDD7)
  const magic = view.getUint32(0, true);

  if (magic === 0x9ac6cdd7) {
    // Placeable WMF - read bounding box
    // Offset 6: left (2 bytes)
    // Offset 8: top (2 bytes)
    // Offset 10: right (2 bytes)
    // Offset 12: bottom (2 bytes)
    // Offset 14: unitsPerInch (2 bytes)
    const left = view.getInt16(6, true);
    const top = view.getInt16(8, true);
    const right = view.getInt16(10, true);
    const bottom = view.getInt16(12, true);
    const unitsPerInch = view.getInt16(14, true) || 1440; // Default to 1440 TWIPs

    const width = right - left;
    const height = bottom - top;

    // Convert to pixels (assuming 96 DPI)
    const pixelWidth = Math.round((width * 96) / unitsPerInch);
    const pixelHeight = Math.round((height * 96) / unitsPerInch);

    return {
      width: pixelWidth || 400,
      height: pixelHeight || 400,
      xExt: width || 400,
      yExt: height || 400,
    };
  }

  // Standard WMF without placeable header - use default dimensions
  return {
    width: 400,
    height: 400,
    xExt: 400,
    yExt: 400,
  };
}

/**
 * Converts an EMF image to SVG data URI.
 *
 * @param {string} data - Base64 encoded data or data URI of the EMF file
 * @param {{ width?: number, height?: number }} [size] - Optional size override
 * @returns {{ dataUri: string, format: string }|null} Data URI plus format, or null if conversion fails
 */
export function convertEmfToSvg(data, size = {}) {
  try {
    // Check if we're in a browser environment with DOM support (or a provided mock)
    if (!ensureDomEnvironment()) {
      console.warn('EMF conversion requires browser environment with DOM support');
      return null;
    }

    const buffer = base64ToArrayBuffer(data);

    // Try to extract embedded bitmap payloads before attempting SVG rendering.
    const bitmapResult = extractBitmapFromEmf(buffer);
    if (bitmapResult) {
      return bitmapResult;
    }

    const dimensions = getEmfDimensions(buffer);

    if (isEmfPlus(buffer)) {
      return createPlaceholder({
        width: size.width || dimensions.width,
        height: size.height || dimensions.height,
        label: 'Unable to render EMF+ image',
      });
    }

    const renderer = new EMFJS.Renderer(buffer);

    const renderSettings = {
      width: String(size.width || dimensions.width) + 'px',
      height: String(size.height || dimensions.height) + 'px',
      wExt: dimensions.wExt,
      hExt: dimensions.hExt,
      xExt: dimensions.xExt,
      yExt: dimensions.yExt,
      mapMode: MM_ANISOTROPIC,
    };

    const svgElement = renderer.render(renderSettings);

    if (!svgElement?.childNodes?.length) {
      return null;
    }

    return { dataUri: svgToDataUri(svgElement), format: 'svg' };
  } catch (error) {
    console.warn('Failed to convert EMF to SVG:', error.message);
    return null;
  }
}

/**
 * Converts a WMF image to SVG data URI.
 *
 * @param {string} data - Base64 encoded data or data URI of the WMF file
 * @param {{ width?: number, height?: number }} [size] - Optional size override
 * @returns {{ dataUri: string, format: string }|null} Data URI plus format, or null if conversion fails
 */
export function convertWmfToSvg(data, size = {}) {
  try {
    // Check if we're in a browser environment with DOM support (or a provided mock)
    if (!ensureDomEnvironment()) {
      console.warn('WMF conversion requires browser environment with DOM support');
      return null;
    }

    const buffer = base64ToArrayBuffer(data);
    if (isEmfHeader(buffer)) {
      // Mis-labeled EMF (sometimes called WMF+) â€“ handle with EMF path so EMF+/bitmap fallbacks apply.
      return convertEmfToSvg(data, size);
    }

    const dimensions = getWmfDimensions(buffer);

    const renderer = new WMFJS.Renderer(buffer);

    const renderSettings = {
      width: String(size.width || dimensions.width) + 'px',
      height: String(size.height || dimensions.height) + 'px',
      xExt: dimensions.xExt,
      yExt: dimensions.yExt,
      mapMode: MM_ANISOTROPIC,
    };

    const svgElement = renderer.render(renderSettings);
    if (!svgElement || !svgElement.childNodes?.length) return null;
    return { dataUri: svgToDataUri(svgElement), format: 'svg' };
  } catch (error) {
    console.warn('Failed to convert WMF to SVG:', error.message);
    return null;
  }
}

/**
 * Converts an EMF or WMF image to SVG data URI based on the file extension.
 *
 * @param {string} dataUri - Base64 data URI of the metafile
 * @param {string} extension - File extension ('emf' or 'wmf')
 * @param {{ width?: number, height?: number }} [size] - Optional size override
 * @returns {{ dataUri: string, format: string }|null} Data URI plus format, or null if conversion fails
 */
export function convertMetafileToSvg(dataUri, extension, size = {}) {
  const ext = extension?.toLowerCase();

  if (ext === 'emf') {
    return convertEmfToSvg(dataUri, size);
  }

  if (ext === 'wmf') {
    return convertWmfToSvg(dataUri, size);
  }

  console.warn(`Unsupported metafile extension: ${extension}`);
  return null;
}

/**
 * Checks if a file extension is a metafile format that can be converted.
 *
 * @param {string} extension - File extension to check
 * @returns {boolean} True if the extension is 'emf' or 'wmf'
 */
export function isMetafileExtension(extension) {
  const ext = extension?.toLowerCase();
  return ext === 'emf' || ext === 'wmf';
}
