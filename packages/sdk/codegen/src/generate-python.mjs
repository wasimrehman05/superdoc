import path from 'node:path';
import {
  camelCase,
  createOperationTree,
  loadContract,
  pascalCase,
  REPO_ROOT,
  sanitizeOperationId,
  writeGeneratedFile,
} from './shared.mjs';

const PYTHON_GENERATED_DIR = path.join(REPO_ROOT, 'packages/sdk/langs/python/superdoc/generated');

// ---------------------------------------------------------------------------
// contract.py â€” embedded contract dict
// ---------------------------------------------------------------------------

function generateContractPy(contract) {
  const payload = JSON.stringify(contract);
  return [
    '# Auto-generated by packages/sdk/codegen/src/generate-python.mjs',
    '',
    'import json',
    '',
    `CONTRACT = json.loads(${JSON.stringify(payload)})`,
    '',
    'OPERATION_INDEX = {op_id: op for op_id, op in CONTRACT["operations"].items()}',
    '',
  ].join('\n');
}

// ---------------------------------------------------------------------------
// Python type mapping
// ---------------------------------------------------------------------------

function toPythonLiteral(value) {
  if (typeof value === 'string') return JSON.stringify(value);
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return value ? 'True' : 'False';
  return 'None';
}

function toPythonType(typeSpec, classNameBase, generatedClasses, classBlocks) {
  if (!typeSpec) return 'Any';

  if (Object.prototype.hasOwnProperty.call(typeSpec, 'const')) {
    return `Literal[${toPythonLiteral(typeSpec.const)}]`;
  }

  if (Array.isArray(typeSpec.oneOf)) {
    const variants = typeSpec.oneOf.map((v, i) =>
      toPythonType(v, `${classNameBase}Variant${i + 1}`, generatedClasses, classBlocks),
    );
    return variants.join(' | ');
  }

  if (typeSpec.enum && Array.isArray(typeSpec.enum)) {
    return typeSpec.enum.map((v) => `Literal[${toPythonLiteral(v)}]`).join(' | ');
  }

  switch (typeSpec.type) {
    case 'string':
      return 'str';
    case 'number':
    case 'integer':
      return 'int | float';
    case 'boolean':
      return 'bool';
    case 'null':
      return 'None';
    case 'json':
      return 'Any';
    case 'array':
      return `list[${toPythonType(typeSpec.items, `${classNameBase}Item`, generatedClasses, classBlocks)}]`;
    case 'object': {
      const className = classNameBase;
      if (!generatedClasses.has(className)) {
        generatedClasses.add(className);
        const lines = [`${className} = TypedDict(`, `    ${JSON.stringify(className)},`, '    {'];
        const properties = Object.entries(typeSpec.properties ?? {});
        if (properties.length === 0) {
          lines.push('    },');
          lines.push('    total=False,');
          lines.push(')');
        } else {
          for (const [name, propSpec] of properties) {
            const propType = toPythonType(
              propSpec,
              `${className}${pascalCase(name)}`,
              generatedClasses,
              classBlocks,
            );
            lines.push(`        ${JSON.stringify(name)}: ${propType},`);
          }
          lines.push('    },');
          lines.push('    total=False,');
          lines.push(')');
        }
        classBlocks.push(lines.join('\n'));
      }
      return className;
    }
    default:
      return 'Any';
  }
}

// ---------------------------------------------------------------------------
// Param type spec helpers
// ---------------------------------------------------------------------------

function paramTypeSpec(param) {
  if (param.type === 'string') return { type: 'string' };
  if (param.type === 'number') return { type: 'number' };
  if (param.type === 'boolean') return { type: 'boolean' };
  if (param.type === 'string[]') return { type: 'array', items: { type: 'string' } };
  if (param.type === 'json' && param.schema) return param.schema;
  return { type: 'json' };
}

function buildParamsObjectSpec(operation) {
  const properties = {};
  const required = [];

  for (const param of operation.params ?? []) {
    properties[param.name] = paramTypeSpec(param);
    if (param.required) required.push(param.name);
  }

  return { type: 'object', properties, required };
}

// ---------------------------------------------------------------------------
// Response and param type generation
// ---------------------------------------------------------------------------

function generateResponseTypes(operations, generatedClasses, classBlocks) {
  const map = new Map();

  for (const [operationId, operation] of Object.entries(operations)) {
    const resultClassName = `Doc${pascalCase(sanitizeOperationId(operationId))}Result`;
    const schema = operation.successSchema ?? operation.outputSchema;
    if (!schema) {
      throw new Error(`Operation ${operationId} missing both successSchema and outputSchema`);
    }
    map.set(operationId, toPythonType(schema, resultClassName, generatedClasses, classBlocks));
  }

  return map;
}

function generateParamTypes(operations, generatedClasses, classBlocks) {
  const map = new Map();

  for (const [operationId, operation] of Object.entries(operations)) {
    const paramsClassName = `Doc${pascalCase(sanitizeOperationId(operationId))}Params`;
    const paramsType = toPythonType(
      buildParamsObjectSpec(operation),
      paramsClassName,
      generatedClasses,
      classBlocks,
    );
    map.set(operationId, paramsType);
  }

  return map;
}

// ---------------------------------------------------------------------------
// Class generation
// ---------------------------------------------------------------------------

function classNameFor(pathParts, asyncMode) {
  const prefix = asyncMode ? '_Async' : '_Sync';
  return `${prefix}${pathParts.map((p) => pascalCase(p)).join('')}Api`;
}

function renderClass(treeNode, pathParts, asyncMode, resultTypeMap, paramTypeMap) {
  const className = classNameFor(pathParts, asyncMode);
  const lines = [`class ${className}:`, '    def __init__(self, runtime):', '        self._runtime = runtime', ''];

  for (const [key, value] of Object.entries(treeNode)) {
    if (value.__operation) {
      const methodName = camelCase(key);
      const operationId = value.__operation.id;
      const resultType = resultTypeMap.get(operationId) ?? 'dict[str, Any]';
      const paramsType = paramTypeMap.get(operationId) ?? 'dict[str, Any]';

      if (asyncMode) {
        lines.push(
          `    async def ${methodName}(self, params: ${paramsType} | None = None, *, timeout_ms=None, stdin_bytes=None) -> ${resultType}:`,
        );
        lines.push(
          `        return await self._runtime.invoke(${JSON.stringify(operationId)}, params or {}, timeout_ms=timeout_ms, stdin_bytes=stdin_bytes)`,
        );
      } else {
        lines.push(
          `    def ${methodName}(self, params: ${paramsType} | None = None, *, timeout_ms=None, stdin_bytes=None) -> ${resultType}:`,
        );
        lines.push(
          `        return self._runtime.invoke(${JSON.stringify(operationId)}, params or {}, timeout_ms=timeout_ms, stdin_bytes=stdin_bytes)`,
        );
      }
      lines.push('');
      continue;
    }

    const propertyName = camelCase(key);
    const nestedClassName = classNameFor([...pathParts, key], asyncMode);
    lines.push('    @property');
    lines.push(`    def ${propertyName}(self):`);
    lines.push(`        return ${nestedClassName}(self._runtime)`);
    lines.push('');
  }

  return lines.join('\n').trimEnd();
}

function renderAllClasses(treeNode, pathParts, asyncMode, resultTypeMap, paramTypeMap) {
  const blocks = [renderClass(treeNode, pathParts, asyncMode, resultTypeMap, paramTypeMap)];

  for (const [key, value] of Object.entries(treeNode)) {
    if (value.__operation) continue;
    blocks.push('');
    blocks.push(renderAllClasses(value, [...pathParts, key], asyncMode, resultTypeMap, paramTypeMap));
  }

  return blocks.join('\n');
}

// ---------------------------------------------------------------------------
// client.py generation
// ---------------------------------------------------------------------------

function generateClientPy(contract) {
  const tree = createOperationTree(contract.operations);
  const generatedClasses = new Set();
  const classBlocks = [];
  const resultTypeMap = generateResponseTypes(contract.operations, generatedClasses, classBlocks);
  const paramTypeMap = generateParamTypes(contract.operations, generatedClasses, classBlocks);
  const sharedTypes = classBlocks.join('\n\n');
  const syncClasses = renderAllClasses(tree, ['doc'], false, resultTypeMap, paramTypeMap);
  const asyncClasses = renderAllClasses(tree, ['doc'], true, resultTypeMap, paramTypeMap);

  return [
    '# Auto-generated by packages/sdk/codegen/src/generate-python.mjs',
    '',
    'from __future__ import annotations',
    '',
    'from typing import Any, Literal, TypedDict',
    '',
    'from ..runtime import SuperDocSyncRuntime, SuperDocAsyncRuntime',
    '',
    sharedTypes,
    '',
    syncClasses,
    '',
    asyncClasses,
    '',
    '',
    'class SuperDocClient:',
    '    def __init__(self, *, env=None, default_change_mode=None):',
    '        self._runtime = SuperDocSyncRuntime(env=env, default_change_mode=default_change_mode)',
    '        self.doc = _SyncDocApi(self._runtime)',
    '',
    '',
    'class AsyncSuperDocClient:',
    '    def __init__(self, *, env=None, default_change_mode=None):',
    '        self._runtime = SuperDocAsyncRuntime(env=env, default_change_mode=default_change_mode)',
    '        self.doc = _AsyncDocApi(self._runtime)',
    '',
  ].join('\n');
}

// ---------------------------------------------------------------------------
// Entry
// ---------------------------------------------------------------------------

export async function generatePythonSdk(contract) {
  const contractContent = generateContractPy(contract);
  const clientContent = generateClientPy(contract);

  await Promise.all([
    writeGeneratedFile(path.join(PYTHON_GENERATED_DIR, 'contract.py'), contractContent),
    writeGeneratedFile(path.join(PYTHON_GENERATED_DIR, 'client.py'), clientContent),
    writeGeneratedFile(
      path.join(PYTHON_GENERATED_DIR, '__init__.py'),
      'from .client import SuperDocClient, AsyncSuperDocClient\n',
    ),
  ]);
}

if (import.meta.url.endsWith(process.argv[1]?.replace(/^file:\/\//, '') ?? '')) {
  const contract = await loadContract();
  await generatePythonSdk(contract);
  console.log('Generated Python SDK files.');
}
