import path from 'node:path';
import {
  camelCase,
  createOperationTree,
  loadContract,
  pascalCase,
  resolveRef,
  REPO_ROOT,
  sanitizeOperationId,
  toNodeType,
  writeGeneratedFile,
} from './shared.mjs';

const NODE_GENERATED_DIR = path.join(REPO_ROOT, 'packages/sdk/langs/node/src/generated');

// ---------------------------------------------------------------------------
// contract.ts — embedded contract JSON
// ---------------------------------------------------------------------------

function generateContractTs(contract) {
  const contractForEmbed = {
    contractVersion: contract.contractVersion,
    ...(contract.$defs ? { $defs: contract.$defs } : {}),
    cli: contract.cli,
    protocol: contract.protocol,
    operations: contract.operations,
  };

  return [
    '/* eslint-disable */',
    '// Auto-generated by packages/sdk/codegen/src/generate-node.mjs',
    '',
    `export const CONTRACT = ${JSON.stringify(contractForEmbed, null, 2)} as const;`,
    '',
    'export type Contract = typeof CONTRACT;',
    `export type OperationEntry = Contract['operations'][keyof Contract['operations']];`,
    '',
  ].join('\n');
}

// ---------------------------------------------------------------------------
// Type generation utilities
// ---------------------------------------------------------------------------

function toTsType(typeSpec, indent = '', $defs = undefined) {
  if (!typeSpec) return 'unknown';
  typeSpec = resolveRef(typeSpec, $defs);

  if (Object.prototype.hasOwnProperty.call(typeSpec, 'const')) {
    return JSON.stringify(typeSpec.const);
  }

  if (Array.isArray(typeSpec.oneOf)) {
    const variants = typeSpec.oneOf.map((v) => toTsType(v, indent, $defs));
    return variants.map((v) => (v.includes('\n') ? `(${v})` : v)).join(' | ');
  }

  if (typeSpec.enum && Array.isArray(typeSpec.enum)) {
    return typeSpec.enum.map((v) => JSON.stringify(v)).join(' | ');
  }

  switch (typeSpec.type) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'null':
      return 'null';
    case 'array':
      return `Array<${toTsType(typeSpec.items, indent, $defs)}>`;
    case 'object': {
      const required = new Set(typeSpec.required ?? []);
      const props = Object.entries(typeSpec.properties ?? {});
      if (props.length === 0) return 'Record<string, unknown>';
      const lines = ['{'];
      for (const [name, propSpec] of props) {
        const propertyKey = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name)
          ? name
          : JSON.stringify(name);
        const opt = required.has(name) ? '' : '?';
        lines.push(`${indent}  ${propertyKey}${opt}: ${toTsType(propSpec, `${indent}  `, $defs)};`);
      }
      lines.push(`${indent}}`);
      return lines.join('\n');
    }
    default:
      return 'unknown';
  }
}

// ---------------------------------------------------------------------------
// Param interface generation (from params[] — transport plane)
// ---------------------------------------------------------------------------

function generateParamInterface(operationId, operation, $defs) {
  const name = `Doc${pascalCase(sanitizeOperationId(operationId))}Params`;
  const lines = [`export interface ${name} {`];

  for (const param of operation.params ?? []) {
    const opt = param.required ? '' : '?';
    let paramType;
    if (param.type === 'json' && param.schema) {
      paramType = toTsType(param.schema, '  ', $defs);
    } else {
      paramType = toNodeType(param.type);
    }
    lines.push(`  ${param.name}${opt}: ${paramType};`);
  }

  lines.push('}');
  return { name, source: lines.join('\n') };
}

// ---------------------------------------------------------------------------
// Result type generation (successSchema ?? outputSchema — schema plane)
// ---------------------------------------------------------------------------

function generateResultType(operationId, operation, $defs) {
  const name = `Doc${pascalCase(sanitizeOperationId(operationId))}Result`;
  const schema = operation.successSchema ?? operation.outputSchema;

  if (!schema) {
    throw new Error(`Operation ${operationId} missing both successSchema and outputSchema`);
  }

  const body = toTsType(schema, '', $defs);
  return { name, source: `export type ${name} = ${body};` };
}

// ---------------------------------------------------------------------------
// Client tree rendering
// ---------------------------------------------------------------------------

function renderTreeNode(treeNode, paramTypeMap, resultTypeMap, indent = '    ') {
  const entries = Object.entries(treeNode);
  const rendered = entries.map(([key, value]) => {
    if (value.__operation) {
      const op = value.__operation;
      const typeName = paramTypeMap.get(op.id);
      const resultTypeName = resultTypeMap.get(op.id);
      const hasRequired = (op.params ?? []).some((p) => p.required);
      const paramsArg = hasRequired ? `params: ${typeName}` : `params: ${typeName} = {}`;
      return `${indent}${camelCase(key)}: (${paramsArg}, options?: InvokeOptions) => runtime.invoke<${resultTypeName}>(CONTRACT.operations[${JSON.stringify(op.id)}], params as unknown as Record<string, unknown>, options),`;
    }

    const nested = renderTreeNode(value, paramTypeMap, resultTypeMap, `${indent}  `);
    return `${indent}${camelCase(key)}: {\n${nested}\n${indent}},`;
  });

  return rendered.join('\n');
}

// ---------------------------------------------------------------------------
// client.ts generation
// ---------------------------------------------------------------------------

function generateClientTs(contract) {
  const $defs = contract.$defs;
  const paramInterfaces = [];
  const resultTypes = [];
  const paramTypeMap = new Map();
  const resultTypeMap = new Map();

  for (const [operationId, operation] of Object.entries(contract.operations)) {
    const { name: pName, source: pSource } = generateParamInterface(operationId, operation, $defs);
    paramTypeMap.set(operationId, pName);
    paramInterfaces.push(pSource);

    const { name: rName, source: rSource } = generateResultType(operationId, operation, $defs);
    resultTypeMap.set(operationId, rName);
    resultTypes.push(rSource);
  }

  const tree = createOperationTree(contract.operations);
  const treeSource = renderTreeNode(tree, paramTypeMap, resultTypeMap);

  return [
    '/* eslint-disable */',
    '// Auto-generated by packages/sdk/codegen/src/generate-node.mjs',
    '',
    "import { CONTRACT } from './contract.js';",
    "import type { SuperDocRuntime, InvokeOptions } from '../runtime/process.js';",
    '',
    paramInterfaces.join('\n\n'),
    '',
    resultTypes.join('\n\n'),
    '',
    'export function createDocApi(runtime: SuperDocRuntime) {',
    '  return {',
    treeSource,
    '  };',
    '}',
    '',
    'export type SuperDocDocApi = ReturnType<typeof createDocApi>;',
    '',
  ].join('\n');
}

// ---------------------------------------------------------------------------
// Entry
// ---------------------------------------------------------------------------

export async function generateNodeSdk(contract) {
  const contractContent = generateContractTs(contract);
  const clientContent = generateClientTs(contract);

  await Promise.all([
    writeGeneratedFile(path.join(NODE_GENERATED_DIR, 'contract.ts'), contractContent),
    writeGeneratedFile(path.join(NODE_GENERATED_DIR, 'client.ts'), clientContent),
  ]);
}

if (import.meta.url.endsWith(process.argv[1]?.replace(/^file:\/\//, '') ?? '')) {
  const contract = await loadContract();
  await generateNodeSdk(contract);
  console.log('Generated Node SDK files.');
}
